package org.optaplanner.python.translator;

import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.optaplanner.python.translator.implementors.CollectionImplementor;
import org.optaplanner.python.translator.implementors.DunderOperatorImplementor;
import org.optaplanner.python.translator.implementors.ExceptionImplementor;
import org.optaplanner.python.translator.implementors.FunctionImplementor;
import org.optaplanner.python.translator.implementors.JavaPythonTypeConversionImplementor;
import org.optaplanner.python.translator.implementors.JumpImplementor;
import org.optaplanner.python.translator.implementors.ObjectImplementor;
import org.optaplanner.python.translator.implementors.PythonBuiltinOperatorImplementor;
import org.optaplanner.python.translator.implementors.PythonConstantsImplementor;
import org.optaplanner.python.translator.implementors.StackManipulationImplementor;
import org.optaplanner.python.translator.implementors.StringImplementor;
import org.optaplanner.python.translator.implementors.VariableImplementor;
import org.optaplanner.python.translator.types.PythonLikeDict;
import org.optaplanner.python.translator.types.PythonLikeFunction;
import org.optaplanner.python.translator.types.PythonLikeList;
import org.optaplanner.python.translator.types.PythonLikeSet;
import org.optaplanner.python.translator.types.PythonLikeTuple;
import org.optaplanner.python.translator.types.PythonString;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PythonBytecodeToJavaBytecodeTranslator {
    /**
     * The ASM generated bytecode. Used by
     * asmClassLoader to create the Java versions of Python methods
     */
    private static final Map<String, byte[]> classNameToBytecode = new HashMap<>();

    public static final String CONSTANTS_STATIC_FIELD_NAME = "co_consts";

    public static final String NAMES_STATIC_FIELD_NAME = "co_names";

    public static final String VARIABLE_NAMES_STATIC_FIELD_NAME = "co_varnames";

    public static final String DEFAULT_POSITIONAL_ARGS_INSTANCE_FIELD_NAME = "__defaults__";

    public static final String DEFAULT_KEYWORD_ARGS_INSTANCE_FIELD_NAME = "__kwdefaults__";

    public static final String ANNOTATION_DIRECTORY_INSTANCE_FIELD_NAME = "__annotations__";
    public static final String CELLS_INSTANCE_FIELD_NAME = "__closure__";

    public static final String QUALIFIED_NAME_INSTANCE_FIELD_NAME = "__qualname__";

    public static final String INTERPRETER_INSTANCE_FIELD_NAME = "__interpreter__";
    private static long generatedClassId = 0L;

    private static final Logger LOGGER = LoggerFactory.getLogger(PythonBytecodeToJavaBytecodeTranslator.class);

    /**
     * A custom classloader that looks for the class in
     * classNameToBytecode
     */
    static ClassLoader asmClassLoader = new ClassLoader() {
        // getName() is an abstract method in Java 11 but not in Java 8
        public String getName() {
            return "OptaPlanner Gizmo Python Bytecode ClassLoader";
        }

        @Override
        public Class<?> findClass(String name) throws ClassNotFoundException {
            if (classNameToBytecode.containsKey(name)) {
                // Gizmo generated class
                byte[] byteCode = classNameToBytecode.get(name);
                return defineClass(name, byteCode, 0, byteCode.length);
            } else {
                // Not a Gizmo generated class; load from parent class loader
                return PythonBytecodeToJavaBytecodeTranslator.class.getClassLoader().loadClass(name);
            }
        }
    };

    public static Path classOutputRootPath = null;

    public static void writeClassOutput(Map<String, byte[]> classNameToBytecode, String className, byte[] classByteCode) {
        classNameToBytecode.put(className, classByteCode);

        if (classOutputRootPath == null) {
            return;
        }

        String[] parts = (className.replace('.', '/') + ".class").split("/");
        Path classFileLocation = classOutputRootPath.resolve(Path.of(".", parts));

        try {
            Files.createDirectories(classFileLocation.getParent());
            Files.write(classFileLocation, classByteCode);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static Method getFunctionalInterfaceMethod(Class<?> interfaceClass) {
        List<Method> candidateList = new ArrayList<>();
        for (Method method : interfaceClass.getMethods()) {
            if (Modifier.isAbstract(method.getModifiers())) {
                candidateList.add(method);
            }
        }

        if (candidateList.isEmpty()) {
            throw new IllegalArgumentException("Class (" + interfaceClass.getName() + ") is not a functional interface: " +
                    "it has no abstract methods.");
        }

        if (candidateList.size() > 1) {
            throw new IllegalArgumentException("Class (" + interfaceClass.getName() + ") is not a functional interface: " +
                    "it has multiple abstract methods (" + candidateList + ").");
        }

        return candidateList.get(0);
    }

    public static <T> T createInstance(Class<T> functionClass, PythonInterpreter pythonInterpreter) {
        return FunctionImplementor.createInstance(new PythonLikeTuple(), new PythonLikeDict(),
                new PythonLikeTuple(), new PythonLikeTuple(),
                PythonString.valueOf(functionClass.getName()),
                functionClass, pythonInterpreter);
    }

    @SuppressWarnings({ "unused" })
    public static <T> T translatePythonBytecode(PythonCompiledFunction pythonCompiledFunction,
            Class<T> javaFunctionalInterfaceType) {
        Class<T> compiledClass = translatePythonBytecodeToClass(pythonCompiledFunction, javaFunctionalInterfaceType);
        try {
            return compiledClass.getConstructor().newInstance();
        } catch (InvocationTargetException | InstantiationException | IllegalAccessException
                | NoSuchMethodException e) {
            throw new IllegalStateException("Impossible State: Unable to create instance of generated class (" +
                    compiledClass + ") despite it being just generated.", e);
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> Class<T> translatePythonBytecodeToClass(PythonCompiledFunction pythonCompiledFunction,
            Class<T> javaFunctionalInterfaceType) {
        Method functionalMethod = getFunctionalInterfaceMethod(javaFunctionalInterfaceType);
        String className = "org.optaplanner.optapy.generated." + "function" + generatedClassId + ".GeneratedFunction";
        generatedClassId++;

        String internalClassName = className.replace('.', '/');
        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);
        classWriter.visit(Opcodes.V11, Modifier.PUBLIC, internalClassName, null, Type.getInternalName(Object.class),
                new String[] { Type.getInternalName(javaFunctionalInterfaceType) });
        Class<?>[] exceptionTypes = functionalMethod.getExceptionTypes();
        String[] exceptionNames = new String[exceptionTypes.length];
        for (int i = 0; i < exceptionTypes.length; i++) {
            exceptionNames[i] = Type.getInternalName(exceptionTypes[i]);
        }

        final boolean isPythonLikeFunction = javaFunctionalInterfaceType.equals(PythonLikeFunction.class);

        createFields(classWriter);
        createConstructor(classWriter, internalClassName);

        MethodVisitor methodVisitor = classWriter.visitMethod(Modifier.PUBLIC,
                functionalMethod.getName(),
                Type.getMethodDescriptor(functionalMethod),
                null,
                exceptionNames);

        translatePythonBytecodeToMethod(functionalMethod, internalClassName, methodVisitor, pythonCompiledFunction,
                isPythonLikeFunction);
        classWriter.visitEnd();

        writeClassOutput(classNameToBytecode, className, classWriter.toByteArray());

        try {
            Class<T> compiledClass = (Class<T>) asmClassLoader.loadClass(className);
            setStaticFields(compiledClass, pythonCompiledFunction);
            return compiledClass;
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException("Impossible State: Unable to load generated class (" +
                    className + ") despite it being just generated.", e);
        }
    }

    private static void createConstructor(ClassWriter classWriter, String className) {
        // Empty constructor, for java code
        MethodVisitor methodVisitor = classWriter.visitMethod(Modifier.PUBLIC, "<init>",
                Type.getMethodDescriptor(Type.VOID_TYPE),
                null, null);
        methodVisitor.visitCode();

        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getInternalName(Object.class), "<init>",
                "()V", false);

        // Positional only and Positional/Keyword default arguments
        methodVisitor.visitInsn(Opcodes.DUP);
        CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, 0);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, DEFAULT_POSITIONAL_ARGS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeTuple.class));

        // Keyword only default arguments
        methodVisitor.visitInsn(Opcodes.DUP);
        CollectionImplementor.buildMap(PythonLikeDict.class, methodVisitor, 0);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, DEFAULT_KEYWORD_ARGS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeDict.class));

        // Annotation Directory as key/value tuple
        methodVisitor.visitInsn(Opcodes.DUP);
        CollectionImplementor.buildMap(PythonLikeDict.class, methodVisitor, 0);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, ANNOTATION_DIRECTORY_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeDict.class));

        // Free variable cells
        methodVisitor.visitInsn(Opcodes.DUP);
        CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, 0);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, CELLS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeTuple.class));

        // Function name
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitLdcInsn(className.replace('/', '.'));
        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(PythonString.class),
                "valueOf", Type.getMethodDescriptor(Type.getType(PythonString.class), Type.getType(String.class)),
                false);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, QUALIFIED_NAME_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonString.class));

        // Interpreter
        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, Type.getInternalName(PythonInterpreter.class), "DEFAULT",
                Type.getDescriptor(PythonInterpreter.class));
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, INTERPRETER_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonInterpreter.class));
        methodVisitor.visitInsn(Opcodes.RETURN);

        methodVisitor.visitMaxs(-1, -1);
        methodVisitor.visitEnd();

        // Full constructor, for MAKE_FUNCTION
        methodVisitor = classWriter.visitMethod(Modifier.PUBLIC, "<init>",
                Type.getMethodDescriptor(Type.VOID_TYPE,
                        Type.getType(PythonLikeTuple.class),
                        Type.getType(PythonLikeDict.class),
                        Type.getType(PythonLikeDict.class),
                        Type.getType(PythonLikeTuple.class),
                        Type.getType(PythonString.class),
                        Type.getType(PythonInterpreter.class)),
                null, null);
        methodVisitor.visitCode();
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getInternalName(Object.class), "<init>",
                "()V", false);

        // Positional only and Positional/Keyword default arguments
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, DEFAULT_POSITIONAL_ARGS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeTuple.class));

        // Keyword only default arguments
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, DEFAULT_KEYWORD_ARGS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeDict.class));

        // Annotation Directory as key/value tuple
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, ANNOTATION_DIRECTORY_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeDict.class));

        // Free variable cells
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 4);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, CELLS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeTuple.class));

        // Function name
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 5);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, QUALIFIED_NAME_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonString.class));

        // Interpreter
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 6);
        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, INTERPRETER_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonInterpreter.class));

        methodVisitor.visitInsn(Opcodes.RETURN);
        methodVisitor.visitMaxs(-1, -1);
        methodVisitor.visitEnd();
    }

    private static void createFields(ClassWriter classWriter) {
        // Static fields
        classWriter.visitField(Modifier.PUBLIC | Modifier.STATIC,
                CONSTANTS_STATIC_FIELD_NAME, Type.getDescriptor(List.class), null, null);
        classWriter.visitField(Modifier.PUBLIC | Modifier.STATIC,
                NAMES_STATIC_FIELD_NAME, Type.getDescriptor(List.class), null, null);
        classWriter.visitField(Modifier.PUBLIC | Modifier.STATIC,
                VARIABLE_NAMES_STATIC_FIELD_NAME, Type.getDescriptor(List.class), null, null);

        // Instance fields
        classWriter.visitField(Modifier.PRIVATE | Modifier.FINAL,
                INTERPRETER_INSTANCE_FIELD_NAME, Type.getDescriptor(PythonInterpreter.class), null, null);
        classWriter.visitField(Modifier.PRIVATE | Modifier.FINAL,
                DEFAULT_POSITIONAL_ARGS_INSTANCE_FIELD_NAME, Type.getDescriptor(PythonLikeTuple.class), null, null);
        classWriter.visitField(Modifier.PRIVATE | Modifier.FINAL,
                DEFAULT_KEYWORD_ARGS_INSTANCE_FIELD_NAME, Type.getDescriptor(PythonLikeDict.class), null, null);
        classWriter.visitField(Modifier.PRIVATE | Modifier.FINAL,
                ANNOTATION_DIRECTORY_INSTANCE_FIELD_NAME, Type.getDescriptor(PythonLikeDict.class), null, null);
        classWriter.visitField(Modifier.PRIVATE | Modifier.FINAL,
                QUALIFIED_NAME_INSTANCE_FIELD_NAME, Type.getDescriptor(PythonString.class), null, null);
        classWriter.visitField(Modifier.PRIVATE | Modifier.FINAL,
                CELLS_INSTANCE_FIELD_NAME, Type.getDescriptor(PythonLikeTuple.class), null, null);
    }

    private static void setStaticFields(Class<?> compiledClass, PythonCompiledFunction pythonCompiledFunction) {
        try {
            compiledClass.getField(CONSTANTS_STATIC_FIELD_NAME).set(null, pythonCompiledFunction.co_constants);

            // Need to convert co_names to python strings (used in __getattribute__)
            List<PythonString> pythonNameList = new ArrayList<>(pythonCompiledFunction.co_names.size());
            for (String name : pythonCompiledFunction.co_names) {
                pythonNameList.add(PythonString.valueOf(name));
            }
            compiledClass.getField(NAMES_STATIC_FIELD_NAME).set(null, pythonNameList);

            List<PythonString> pythonVariableNameList = new ArrayList<>(pythonCompiledFunction.co_varnames.size());
            for (String name : pythonCompiledFunction.co_varnames) {
                pythonVariableNameList.add(PythonString.valueOf(name));
            }
            compiledClass.getField(VARIABLE_NAMES_STATIC_FIELD_NAME).set(null, pythonVariableNameList);
        } catch (IllegalAccessException | NoSuchFieldException e) {
            throw new IllegalStateException("Impossible state: generated class (" + compiledClass +
                    ") does not have static field \"" + CONSTANTS_STATIC_FIELD_NAME + "\"", e);
        }
    }

    private static void translatePythonBytecodeToMethod(Method method, String className, MethodVisitor methodVisitor,
            PythonCompiledFunction pythonCompiledFunction, boolean isPythonLikeFunction) {
        for (Parameter parameter : method.getParameters()) {
            methodVisitor.visitParameter(parameter.getName(), 0);
        }
        methodVisitor.visitCode();

        Map<Integer, Label> bytecodeCounterToLabelMap = new HashMap<>();
        LocalVariableHelper localVariableHelper = new LocalVariableHelper(method.getParameters(), pythonCompiledFunction);

        if (!isPythonLikeFunction) {
            // Need to convert Java parameters
            for (int i = 0; i < localVariableHelper.parameters.length; i++) {
                JavaPythonTypeConversionImplementor.copyParameter(methodVisitor, localVariableHelper, i);
            }
        } else {
            // Need to move Python parameters from the argument list + keyword list to their variable slots
            movePythonParametersToSlots(methodVisitor, className, pythonCompiledFunction, localVariableHelper);
        }

        for (int i = 0; i < localVariableHelper.getNumberOfBoundCells(); i++) {
            VariableImplementor.createCell(methodVisitor, localVariableHelper, i);
        }

        for (int i = 0; i < localVariableHelper.getNumberOfFreeCells(); i++) {
            VariableImplementor.setupFreeVariableCell(methodVisitor, className, localVariableHelper, i);
        }

        Map<Integer, List<Runnable>> bytecodeIndexToArgumentorsMap = new HashMap<>();
        for (PythonBytecodeInstruction instruction : pythonCompiledFunction.instructionList) {
            translatePythonBytecodeInstruction(method, className, methodVisitor, pythonCompiledFunction, instruction,
                    bytecodeCounterToLabelMap, bytecodeIndexToArgumentorsMap, localVariableHelper);
        }

        methodVisitor.visitMaxs(-1, -1);
        methodVisitor.visitEnd();
    }

    private static void movePythonParametersToSlots(MethodVisitor methodVisitor,
            String internalClassName,
            PythonCompiledFunction pythonCompiledFunction,
            LocalVariableHelper localVariableHelper) {
        // Call {@link FunctionImplementor#extractArguments} to extract argument into a list
        methodVisitor.visitLdcInsn(pythonCompiledFunction.co_argcount);
        methodVisitor.visitLdcInsn(pythonCompiledFunction.co_kwonlyargcount);
        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, internalClassName, VARIABLE_NAMES_STATIC_FIELD_NAME,
                Type.getDescriptor(List.class));
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, internalClassName, DEFAULT_POSITIONAL_ARGS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeTuple.class));
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, internalClassName, DEFAULT_KEYWORD_ARGS_INSTANCE_FIELD_NAME,
                Type.getDescriptor(PythonLikeDict.class));
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);

        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(FunctionImplementor.class), "extractArguments",
                Type.getMethodDescriptor(Type.getType(List.class), Type.INT_TYPE, Type.INT_TYPE,
                        Type.getType(List.class), Type.getType(List.class),
                        Type.getType(Map.class), Type.getType(List.class),
                        Type.getType(Map.class)),
                false);

        for (int i = 0; i < pythonCompiledFunction.co_argcount; i++) {
            methodVisitor.visitInsn(Opcodes.DUP);
            methodVisitor.visitLdcInsn(i);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(List.class), "get",
                    Type.getMethodDescriptor(Type.getType(Object.class), Type.INT_TYPE), true);
            methodVisitor.visitVarInsn(Opcodes.ASTORE, localVariableHelper.getPythonLocalVariableSlot(i));
            methodVisitor.visitInsn(Opcodes.POP);
        }
        methodVisitor.visitInsn(Opcodes.POP);
    }

    /**
     * Used for debugging; prints the offset of the instruction when it is executed
     */
    @SuppressWarnings("unused")
    private static void trace(MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {
        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, Type.getInternalName(System.class),
                "out", Type.getDescriptor(PrintStream.class));
        methodVisitor.visitLdcInsn(instruction.offset);
        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PrintStream.class),
                "println", Type.getMethodDescriptor(Type.VOID_TYPE, Type.INT_TYPE),
                false);
    }

    /**
     * Used for debugging; prints TOS
     */
    @SuppressWarnings("unused")
    public static void print(MethodVisitor methodVisitor) {
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, Type.getInternalName(System.class),
                "out", Type.getDescriptor(PrintStream.class));
        methodVisitor.visitInsn(Opcodes.SWAP);
        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PrintStream.class),
                "println", Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(Object.class)),
                false);
    }

    private static void translatePythonBytecodeInstruction(Method method,
            String className,
            MethodVisitor methodVisitor,
            PythonCompiledFunction pythonCompiledFunction,
            PythonBytecodeInstruction instruction,
            Map<Integer, Label> bytecodeCounterToLabelMap,
            Map<Integer, List<Runnable>> bytecodeCounterToCodeArgumenterList,
            LocalVariableHelper localVariableHelper) {
        if (instruction.isJumpTarget) {
            Label label = bytecodeCounterToLabelMap.computeIfAbsent(instruction.offset, offset -> new Label());
            methodVisitor.visitLabel(label);
        }

        bytecodeCounterToCodeArgumenterList.getOrDefault(instruction.offset, List.of()).forEach(Runnable::run);

        BiConsumer<Integer, Runnable> bytecodeIndexArgumentorConsumer = (bytecodeIndex, runnable) -> {
            bytecodeCounterToCodeArgumenterList
                    .computeIfAbsent(bytecodeIndex, key -> new ArrayList<>()).add(runnable);
        };

        switch (instruction.opcode) {
            // **************************************************
            // Meta Operations
            // **************************************************
            case NOP: { // use brackets to scope local variables
                methodVisitor.visitInsn(Opcodes.NOP);
                break;
            }

            case EXTENDED_ARG:
                break;

            // **************************************************
            // Stack Manipulation
            // **************************************************
            case POP_TOP: {
                StackManipulationImplementor.popTOS(methodVisitor);
                break;
            }
            case ROT_TWO: {
                StackManipulationImplementor.swap(methodVisitor);
                break;
            }
            case ROT_THREE: {
                StackManipulationImplementor.rotateThree(methodVisitor);
                break;
            }
            case ROT_FOUR: {
                StackManipulationImplementor.rotateFour(methodVisitor, localVariableHelper);
                break;
            }
            case DUP_TOP: {
                StackManipulationImplementor.duplicateTOS(methodVisitor);
                break;
            }
            case DUP_TOP_TWO: {
                StackManipulationImplementor.duplicateTOSAndTOS1(methodVisitor);
                break;
            }

            // **************************************************
            // Object Operations
            // **************************************************
            case IS_OP: {
                PythonBuiltinOperatorImplementor.isOperator(methodVisitor, instruction);
                break;
            }

            case LOAD_ATTR: {
                ObjectImplementor.getAttribute(methodVisitor, className, instruction);
                break;
            }
            case STORE_ATTR: {
                ObjectImplementor.setAttribute(methodVisitor, className, instruction, localVariableHelper);
                break;
            }
            case DELETE_ATTR: {
                ObjectImplementor.deleteAttribute(methodVisitor, className, instruction);
                break;
            }

            // **************************************************
            // Collection Access Operations
            // **************************************************
            case GET_ITER: {
                DunderOperatorImplementor.unaryOperator(methodVisitor, PythonUnaryOperator.ITERATOR);
                break;
            }
            case STORE_SUBSCR: {
                CollectionImplementor.setItem(methodVisitor, localVariableHelper);
                break;
            }
            case DEL_SUBSCR: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.DELETE_ITEM);
                break;
            }
            case CONTAINS_OP: {
                CollectionImplementor.containsOperator(methodVisitor, instruction);
                break;
            }
            case UNPACK_SEQUENCE: {
                CollectionImplementor.unpackSequence(methodVisitor, instruction.arg, localVariableHelper);
                break;
            }
            case UNPACK_EX: {
                CollectionImplementor.unpackSequenceWithTail(methodVisitor, instruction.arg, localVariableHelper);
                break;
            }

            // **************************************************
            // Collection Construction Operations
            // **************************************************
            case BUILD_SLICE:
                break;

            case BUILD_TUPLE: {
                CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, instruction.arg);
                break;
            }
            case BUILD_LIST: {
                CollectionImplementor.buildCollection(PythonLikeList.class, methodVisitor, instruction.arg);
                break;
            }
            case BUILD_SET: {
                CollectionImplementor.buildCollection(PythonLikeSet.class, methodVisitor, instruction.arg);
                break;
            }
            case BUILD_MAP: {
                CollectionImplementor.buildMap(PythonLikeDict.class, methodVisitor, instruction.arg);
                break;
            }
            case BUILD_CONST_KEY_MAP: {
                CollectionImplementor.buildConstKeysMap(PythonLikeDict.class, methodVisitor, instruction.arg);
                break;
            }

            // **************************************************
            // Collection Edit Operations
            // **************************************************
            case LIST_TO_TUPLE: {
                CollectionImplementor.convertListToTuple(methodVisitor);
                break;
            }

            case SET_ADD:
            case LIST_APPEND: {
                // SET_ADD and LIST_APPEND have the same bytecode
                CollectionImplementor.collectionAdd(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case MAP_ADD: {
                CollectionImplementor.mapPut(methodVisitor, instruction, localVariableHelper);
                break;
            }

            case LIST_EXTEND:
            case SET_UPDATE: {
                // LIST_EXTEND and SET_UPDATE have the same bytecode
                CollectionImplementor.collectionAddAll(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case DICT_UPDATE: {
                CollectionImplementor.mapPutAll(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case DICT_MERGE: {
                CollectionImplementor.mapPutAllOnlyIfAllNewElseThrow(methodVisitor, instruction, localVariableHelper);
                break;
            }

            // **************************************************
            // Control Flow Operations
            // **************************************************
            case SETUP_WITH:
                break;

            case RETURN_VALUE: {
                JavaPythonTypeConversionImplementor.returnValue(methodVisitor, method);
                break;
            }
            case JUMP_FORWARD: {
                JumpImplementor.jumpRelative(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }
            case POP_JUMP_IF_TRUE: {
                JumpImplementor.popAndJumpIfTrue(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }
            case POP_JUMP_IF_FALSE: {
                JumpImplementor.popAndJumpIfFalse(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }
            case JUMP_IF_NOT_EXC_MATCH: {
                JumpImplementor.popAndJumpIfExceptionDoesNotMatch(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }
            case JUMP_IF_TRUE_OR_POP: {
                JumpImplementor.jumpIfTrueElsePop(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }
            case JUMP_IF_FALSE_OR_POP: {
                JumpImplementor.jumpIfFalseElsePop(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }
            case JUMP_ABSOLUTE: {
                JumpImplementor.jumpAbsolute(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }
            case FOR_ITER: {
                CollectionImplementor.iterateIterator(methodVisitor, instruction, bytecodeCounterToLabelMap);
                break;
            }

            // **************************************************
            // Function Operations
            // **************************************************
            case CALL_FUNCTION: {
                FunctionImplementor.callFunction(methodVisitor, instruction);
                break;
            }
            case CALL_FUNCTION_KW: {
                FunctionImplementor.callFunctionWithKeywords(methodVisitor, instruction);
                break;
            }
            case CALL_FUNCTION_EX: {
                FunctionImplementor.callFunctionUnpack(methodVisitor, instruction);
                break;
            }
            case LOAD_METHOD: {
                FunctionImplementor.loadMethod(methodVisitor, className, pythonCompiledFunction, instruction);
                break;
            }
            case CALL_METHOD: {
                FunctionImplementor.callMethod(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case MAKE_FUNCTION: {
                FunctionImplementor.createFunction(methodVisitor, className, instruction, localVariableHelper);
                break;
            }

            // **************************************************
            // Variable Operations
            // **************************************************
            case LOAD_CONST: {
                PythonConstantsImplementor.loadConstant(methodVisitor, className, instruction.arg);
                break;
            }

            case LOAD_NAME:
                break;
            case STORE_NAME:
                break;
            case DELETE_NAME:
                break;

            case LOAD_GLOBAL: {
                VariableImplementor.loadGlobalVariable(methodVisitor, className, pythonCompiledFunction, instruction);
                break;
            }
            case STORE_GLOBAL: {
                VariableImplementor.storeInGlobalVariable(methodVisitor, className, pythonCompiledFunction, instruction);
                break;
            }
            case DELETE_GLOBAL: {
                VariableImplementor.deleteGlobalVariable(methodVisitor, className, pythonCompiledFunction, instruction);
                break;
            }

            case LOAD_FAST: {
                VariableImplementor.loadLocalVariable(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case STORE_FAST: {
                VariableImplementor.storeInLocalVariable(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case DELETE_FAST: {
                VariableImplementor.deleteLocalVariable(methodVisitor, instruction, localVariableHelper);
                break;
            }

            case LOAD_CLOSURE: {
                VariableImplementor.loadCell(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case LOAD_DEREF: {
                VariableImplementor.loadCellVariable(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case STORE_DEREF: {
                VariableImplementor.storeInCellVariable(methodVisitor, instruction, localVariableHelper);
                break;
            }
            case DELETE_DEREF: {
                VariableImplementor.deleteCellVariable(methodVisitor, instruction, localVariableHelper);
                break;
            }

            case LOAD_CLASSDEREF:
                break;

            // **************************************************
            // Asynchronous Operations
            // **************************************************
            case GET_AWAITABLE:
                break;
            case GET_AITER:
                break;
            case GET_ANEXT:
                break;
            case END_ASYNC_FOR:
                break;
            case BEFORE_ASYNC_WITH:
                break;
            case SETUP_ASYNC_WITH:
                break;

            // **************************************************
            // Generator Operations
            // **************************************************
            case YIELD_VALUE:
                break;
            case YIELD_FROM:
                break;
            case GET_YIELD_FROM_ITER:
                break;

            // **************************************************
            // Exception Handling Operations
            // **************************************************
            case LOAD_ASSERTION_ERROR: {
                ExceptionImplementor.createAssertionError(methodVisitor);
                break;
            }
            case POP_BLOCK: {
                // Do nothing, since Java already popped the block for us
                break;
            }
            case POP_EXCEPT: {
                ExceptionImplementor.endExcept(methodVisitor, localVariableHelper);
                break;
            }
            case WITH_EXCEPT_START: {
                // TODO
                break;
            }
            case RERAISE: {
                ExceptionImplementor.reraise(methodVisitor);
                break;
            }
            case SETUP_FINALLY: {
                ExceptionImplementor.createTryFinallyBlock(methodVisitor, className, instruction, localVariableHelper,
                        bytecodeCounterToLabelMap,
                        bytecodeIndexArgumentorConsumer);
                break;
            }
            case RAISE_VARARGS: {
                ExceptionImplementor.raiseWithOptionalExceptionAndCause(methodVisitor, instruction, localVariableHelper);
                break;
            }

            // **************************************************
            // Import Operations
            // **************************************************
            case IMPORT_STAR:
                break;
            case IMPORT_NAME:
                break;
            case IMPORT_FROM:
                break;

            // **************************************************
            // String Operations
            // **************************************************
            case PRINT_EXPR: {
                StringImplementor.print(methodVisitor, className);
                break;
            }

            case FORMAT_VALUE: {
                StringImplementor.formatValue(methodVisitor, instruction);
                break;
            }

            case BUILD_STRING: {
                StringImplementor.buildString(methodVisitor, instruction.arg);
                break;
            }

            // **************************************************
            // Class Operations
            // **************************************************
            case LOAD_BUILD_CLASS:
                break;

            case SETUP_ANNOTATIONS:
                break;

            // **************************************************
            // Dunder Operations
            // **************************************************
            case COMPARE_OP: {
                DunderOperatorImplementor.compareValues(methodVisitor, CompareOp.getOp(instruction.arg));
                break;
            }
            case UNARY_POSITIVE: {
                DunderOperatorImplementor.unaryOperator(methodVisitor, PythonUnaryOperator.POSITIVE);
                break;
            }
            case UNARY_NEGATIVE: {
                DunderOperatorImplementor.unaryOperator(methodVisitor, PythonUnaryOperator.NEGATIVE);
                break;
            }
            case UNARY_NOT: {
                DunderOperatorImplementor.unaryOperator(methodVisitor, PythonUnaryOperator.AS_BOOLEAN);
                PythonBuiltinOperatorImplementor.performNotOnTOS(methodVisitor);
                break;
            }
            case UNARY_INVERT: {
                DunderOperatorImplementor.unaryOperator(methodVisitor, PythonUnaryOperator.INVERT);
                break;
            }

            case BINARY_POWER: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.POWER);
                break;
            }
            case BINARY_MULTIPLY: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.MULTIPLY);
                break;
            }
            case BINARY_MATRIX_MULTIPLY: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.MATRIX_MULTIPLY);
                break;
            }
            case BINARY_FLOOR_DIVIDE: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.FLOOR_DIVIDE);
                break;
            }
            case BINARY_TRUE_DIVIDE: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.TRUE_DIVIDE);
                break;
            }
            case BINARY_MODULO: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.MODULO);
                break;
            }
            case BINARY_ADD: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.ADD);
                break;
            }
            case BINARY_SUBTRACT: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.SUBTRACT);
                break;
            }
            case BINARY_SUBSCR: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.GET_ITEM);
                break;
            }
            case BINARY_LSHIFT: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.LSHIFT);
                break;
            }
            case BINARY_RSHIFT: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.RSHIFT);
                break;
            }
            case BINARY_AND: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.AND);
                break;
            }
            case BINARY_XOR: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.XOR);
                break;
            }
            case BINARY_OR: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.OR);
                break;
            }

            // **************************************************
            // In-place Dunder Operations
            // **************************************************
            case INPLACE_POWER: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_POWER);
                break;
            }
            case INPLACE_MULTIPLY: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_MULTIPLY);
                break;
            }
            case INPLACE_MATRIX_MULTIPLY: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_MATRIX_MULTIPLY);
                break;
            }
            case INPLACE_FLOOR_DIVIDE: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_FLOOR_DIVIDE);
                break;
            }
            case INPLACE_TRUE_DIVIDE: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_TRUE_DIVIDE);
                break;
            }
            case INPLACE_MODULO: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_MODULO);
                break;
            }
            case INPLACE_ADD: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_ADD);
                break;
            }
            case INPLACE_SUBTRACT: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_SUBTRACT);
                break;
            }
            case INPLACE_LSHIFT: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_LSHIFT);
                break;
            }
            case INPLACE_RSHIFT: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_RSHIFT);
                break;
            }
            case INPLACE_AND: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_AND);
                break;
            }
            case INPLACE_XOR: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_XOR);
                break;
            }
            case INPLACE_OR: {
                DunderOperatorImplementor.binaryOperator(methodVisitor, PythonBinaryOperators.INPLACE_OR);
                break;
            }

            default:
                throw new UnsupportedOperationException("Opcode not implemented: " + instruction.opname);
        }
    }
}
